package net.dongliu.dbutils;

import net.dongliu.dbutils.exception.UncheckedSQLException;

import javax.annotation.Nullable;
import java.sql.*;
import java.time.*;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.concurrent.Executor;

/**
 * For hold sql execute infos
 *
 * @author Liu Dong
 */
public abstract class SQLContext<T extends SQLContext<T>> {

    protected final Connection connection;
    protected String clause;
    protected int fetchSize;
    @Nullable
    protected String[] keyColumns;

    SQLContext(Connection connection, boolean closeConn) {
        this.connection = new MyConnection(connection, closeConn);
    }

    T clause(String clause) {
        this.clause = Objects.requireNonNull(clause);
        return self();
    }

    /**
     * This params works for query method.
     * <p>
     * Gives the JDBC driver a hint as to the number of rows that should
     * be fetched from the database when more rows are needed for
     * <code>ResultSet</code> objects generated by this <code>Statement</code>.
     * If the value specified is zero, then the hint is ignored.
     * The default value is zero.
     * </p>
     * <p>
     * if setFetchSize(10) is being called and the driver is ignoring it, there are probably only two options:
     * 1. Try a different JDBC driver that will honor the fetch-size hint.
     * 2. Look at driver-specific properties on the Connection (URL and/or property map when creating the
     * Connection instance).
     * </p>
     */
    public T fetchSize(int fetchSize) {
        this.fetchSize = fetchSize;
        return self();
    }

    /**
     * Key columns to tell which columns should returned for insert operations.
     * If not set, will try to fetch key columns via driver
     */
    public T keyColumns(String... columns) {
        this.keyColumns = Objects.requireNonNull(columns);
        return self();
    }

    protected abstract T self();

    /**
     * Fill the PreparedStatement replacement parameters with the given objects.
     *
     * @param stmt   PreparedStatement to fill
     * @param params Query replacement parameters; null is a valid value to pass in.
     */
    protected void fillStatement(PreparedStatement stmt, Object... params) throws SQLException {

        // check the parameter count, if we can
        for (int i = 0; i < params.length; i++) {
            Object param = params[i];
            if (param == null) {
                // VARCHAR works with many drivers regardless
                // of the actual column type. Oddly, NULL and
                // OTHER don't work with Oracle's drivers.
                int sqlType = Types.VARCHAR;
                stmt.setNull(i + 1, sqlType);
                continue;
            }
            if (param instanceof Instant) {
                param = Timestamp.from((Instant) param);
            } else if (param instanceof LocalDate) {
                param = java.sql.Date.valueOf((LocalDate) param);
            } else if (param instanceof LocalTime) {
                param = Time.valueOf((LocalTime) param);
            } else if (param instanceof LocalDateTime) {
                param = Timestamp.valueOf((LocalDateTime) param);
            } else if (param instanceof ZonedDateTime) {
                param = Timestamp.from(((ZonedDateTime) param).toInstant());
            } else if (param instanceof OffsetDateTime) {
                param = Timestamp.from(((OffsetDateTime) param).toInstant());
            } else if (param instanceof OffsetTime) {
                //TODO: with timezone
                param = Time.valueOf(((OffsetTime) param).toLocalTime());
            }
            stmt.setObject(i + 1, param);
        }
    }


    protected void close(Connection connection, Throwable t) throws UncheckedSQLException {
        try {
            connection.close();
        } catch (Throwable e) {
            t.addSuppressed(e);
        }
        if (t instanceof SQLException) {
            throw new UncheckedSQLException((SQLException) t);
        }
        throw new RuntimeException("should not happen");
    }

    protected void close(Statement statement, Connection connection, Throwable t) throws UncheckedSQLException {
        try {
            statement.close();
        } catch (Throwable e) {
            t.addSuppressed(e);
        }
        try {
            connection.close();
        } catch (Throwable e) {
            t.addSuppressed(e);
        }
        if (t instanceof SQLException) {
            throw new UncheckedSQLException((SQLException) t);
        }
        throw new RuntimeException("should not happen");
    }


    private static class MyConnection implements Connection {
        private final Connection connection;
        private final boolean closeConn;

        private MyConnection(Connection connection, boolean closeConn) {
            this.connection = connection;
            this.closeConn = closeConn;
        }

        @Override
        public Statement createStatement() throws SQLException {
            return connection.createStatement();
        }

        @Override
        public PreparedStatement prepareStatement(String sql) throws SQLException {
            return connection.prepareStatement(sql);
        }

        @Override
        public CallableStatement prepareCall(String sql) throws SQLException {
            return connection.prepareCall(sql);
        }

        @Override
        public String nativeSQL(String sql) throws SQLException {
            return connection.nativeSQL(sql);
        }

        @Override
        public void setAutoCommit(boolean autoCommit) throws SQLException {
            connection.setAutoCommit(autoCommit);
        }

        @Override
        public boolean getAutoCommit() throws SQLException {
            return connection.getAutoCommit();
        }

        @Override
        public void commit() throws SQLException {
            connection.commit();
        }

        @Override
        public void rollback() throws SQLException {
            connection.rollback();
        }

        @Override
        public void close() throws SQLException {
            if (closeConn) {
                connection.close();
            }
        }

        @Override
        public boolean isClosed() throws SQLException {
            return connection.isClosed();
        }

        @Override
        public DatabaseMetaData getMetaData() throws SQLException {
            return connection.getMetaData();
        }

        @Override
        public void setReadOnly(boolean readOnly) throws SQLException {
            connection.setReadOnly(readOnly);
        }

        @Override
        public boolean isReadOnly() throws SQLException {
            return connection.isReadOnly();
        }

        @Override
        public void setCatalog(String catalog) throws SQLException {
            connection.setCatalog(catalog);
        }

        @Override
        public String getCatalog() throws SQLException {
            return connection.getCatalog();
        }

        @Override
        public void setTransactionIsolation(int level) throws SQLException {
            connection.setTransactionIsolation(level);
        }

        @Override
        public int getTransactionIsolation() throws SQLException {
            return connection.getTransactionIsolation();
        }

        @Override
        public SQLWarning getWarnings() throws SQLException {
            return connection.getWarnings();
        }

        @Override
        public void clearWarnings() throws SQLException {
            connection.clearWarnings();
        }

        @Override
        public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
            return connection.createStatement(resultSetType, resultSetConcurrency);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, int resultSetType,
                                                  int resultSetConcurrency) throws SQLException {
            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
        }

        @Override
        public CallableStatement prepareCall(String sql, int resultSetType,
                                             int resultSetConcurrency) throws SQLException {
            return connection.prepareCall(sql, resultSetType, resultSetConcurrency);
        }

        @Override
        public Map<String, Class<?>> getTypeMap() throws SQLException {
            return connection.getTypeMap();
        }

        @Override
        public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
            connection.setTypeMap(map);
        }

        @Override
        public void setHoldability(int holdability) throws SQLException {
            connection.setHoldability(holdability);
        }

        @Override
        public int getHoldability() throws SQLException {
            return connection.getHoldability();
        }

        @Override
        public Savepoint setSavepoint() throws SQLException {
            return connection.setSavepoint();
        }

        @Override
        public Savepoint setSavepoint(String name) throws SQLException {
            return connection.setSavepoint(name);
        }

        @Override
        public void rollback(Savepoint savepoint) throws SQLException {
            connection.rollback(savepoint);
        }

        @Override
        public void releaseSavepoint(Savepoint savepoint) throws SQLException {
            connection.releaseSavepoint(savepoint);
        }

        @Override
        public Statement createStatement(int resultSetType, int resultSetConcurrency,
                                         int resultSetHoldability) throws SQLException {
            return connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
                                                  int resultSetHoldability) throws SQLException {
            return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        }

        @Override
        public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
                                             int resultSetHoldability) throws SQLException {
            return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
            return connection.prepareStatement(sql, autoGeneratedKeys);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
            return connection.prepareStatement(sql, columnIndexes);
        }

        @Override
        public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
            return connection.prepareStatement(sql, columnNames);
        }

        @Override
        public Clob createClob() throws SQLException {
            return connection.createClob();
        }

        @Override
        public Blob createBlob() throws SQLException {
            return connection.createBlob();
        }

        @Override
        public NClob createNClob() throws SQLException {
            return connection.createNClob();
        }

        @Override
        public SQLXML createSQLXML() throws SQLException {
            return connection.createSQLXML();
        }

        @Override
        public boolean isValid(int timeout) throws SQLException {
            return connection.isValid(timeout);
        }

        @Override
        public void setClientInfo(String name, String value) throws SQLClientInfoException {
            connection.setClientInfo(name, value);
        }

        @Override
        public void setClientInfo(Properties properties) throws SQLClientInfoException {
            connection.setClientInfo(properties);
        }

        @Override
        public String getClientInfo(String name) throws SQLException {
            return connection.getClientInfo(name);
        }

        @Override
        public Properties getClientInfo() throws SQLException {
            return connection.getClientInfo();
        }

        @Override
        public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
            return connection.createArrayOf(typeName, elements);
        }

        @Override
        public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
            return connection.createStruct(typeName, attributes);
        }

        @Override
        public void setSchema(String schema) throws SQLException {
            connection.setSchema(schema);
        }

        @Override
        public String getSchema() throws SQLException {
            return connection.getSchema();
        }

        @Override
        public void abort(Executor executor) throws SQLException {
            connection.abort(executor);
        }

        @Override
        public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
            connection.setNetworkTimeout(executor, milliseconds);
        }

        @Override
        public int getNetworkTimeout() throws SQLException {
            return connection.getNetworkTimeout();
        }

        @Override
        @SuppressWarnings("unchecked")
        public <T> T unwrap(Class<T> iface) throws SQLException {
            if (iface.isAssignableFrom(connection.getClass())) {
                return (T) connection;
            }
            return connection.unwrap(iface);
        }

        @Override
        public boolean isWrapperFor(Class<?> iface) throws SQLException {
            if (iface.isAssignableFrom(connection.getClass())) {
                return true;
            }
            return connection.isWrapperFor(iface);
        }
    }
}
